# src/projectdavid/events.py
from dataclasses import asdict, dataclass
from typing import Any, Callable, Dict, Optional


@dataclass
class StreamEvent:
    """Base class for all stream events with built-in serialization."""

    run_id: str

    def to_dict(self) -> Dict[str, Any]:
        """Converts the dataclass to a dictionary and adds the 'type' discriminator."""
        data = asdict(self)
        # Identify the event type for the front-end
        data["type"] = self.get_event_type()
        return data

    def get_event_type(self) -> str:
        mapping = {
            "ContentEvent": "content",
            "ReasoningEvent": "reasoning",
            "DecisionEvent": "decision",
            "PlanEvent": "plan",
            "ToolCallRequestEvent": "tool_call_manifest",
            "StatusEvent": "status",
            "ActivityEvent": "activity",
            "ScratchpadEvent": "scratchpad",  # <--- NEW MAPPING
            "HotCodeEvent": "hot_code",
            "CodeExecutionOutputEvent": "code_output",
            "ComputerExecutionOutputEvent": "computer_output",
            "CodeExecutionGeneratedFileEvent": "generated_file",
        }
        return mapping.get(self.__class__.__name__, "unknown")


@dataclass
class ScratchpadEvent(StreamEvent):
    """
    Represents a scratchpad operation (read/update/append).
    Corresponds to the ScratchpadStatus.js frontend component.
    """

    operation: str  # 'read', 'update', 'append'
    activity: str  # Human readable status e.g. "ðŸ“ Appending to scratchpad..."
    state: str  # 'in_progress', 'success', 'error'
    entry: Optional[str] = None  # For 'append' operations
    content: Optional[str] = None  # For 'update' or 'read' operations

    def __str__(self):
        return f"Scratchpad[{self.operation}]: {self.activity}"


@dataclass
class ActivityEvent(StreamEvent):
    """Represents user-visible progress updates during tool execution."""

    activity: (
        str  # The activity message (e.g., "Spawning ephemeral research assistant...")
    )
    tool: Optional[str] = None  # Optional tool name for context
    state: str = "in_progress"  # in_progress, completed, error

    def __str__(self):
        return self.activity


@dataclass
class ContentEvent(StreamEvent):
    """Represents a text delta from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class ReasoningEvent(StreamEvent):
    """Represents a 'thinking' delta (DeepSeek R1/V3)."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class DecisionEvent(StreamEvent):
    """Represents a structural decision payload (JSON) from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class PlanEvent(StreamEvent):
    """Represents a strategic planning delta (Level 3) from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class HotCodeEvent(StreamEvent):
    """Real-time code being typed by the model BEFORE execution."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionOutputEvent(StreamEvent):
    """Stdout/Stderr output from the code sandbox."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class ComputerExecutionOutputEvent(StreamEvent):
    """Output from the shell/computer execution tool."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionGeneratedFileEvent(StreamEvent):
    """A file (plot, csv) generated by the code interpreter."""

    filename: str
    file_id: str
    mime_type: str
    url: Optional[str] = None
    base64_data: Optional[str] = None


@dataclass
class StatusEvent(StreamEvent):
    """Represents a lifecycle change (complete, failed, tool_output_received)."""

    status: str
    # Added to match WebSearchMixin payloads
    message: Optional[str] = None
    tool: Optional[str] = None


class ToolCallRequestEvent(StreamEvent):
    """
    A fully accumulated tool call request.
    Level 3 Update: Added tool_call_id to ensure ID-Parity between the
    Assistant's plan and the Tool's response in the dialogue history.
    """

    def __init__(
        self,
        run_id: str,
        tool_name: str,
        args: Dict[str, Any],
        thread_id: str,
        assistant_id: str,
        _runs_client: Any,
        _actions_client: Any,
        _messages_client: Any,
        action_id: Optional[str] = None,
        tool_call_id: Optional[
            str
        ] = None,  # [L3] The Dialogue ID generated by the parser
    ):
        super().__init__(run_id)
        self.tool_name = tool_name
        self.args = args
        self.action_id = action_id
        self.tool_call_id = tool_call_id  # [L3] Store for linking results
        self._thread_id = thread_id
        self._assistant_id = assistant_id
        self._runs_client = _runs_client
        self._actions_client = _actions_client
        self._messages_client = _messages_client

        # Level 2/3 Turn-Management State
        self.executed = False

    def to_dict(self) -> Dict[str, Any]:
        # Include tool_call_id in the dictionary for UI transparency and debugging
        return {
            "type": "tool_call_manifest",
            "run_id": self.run_id,
            "tool": self.tool_name,
            "args": self.args,
            "action_id": self.action_id,
            "tool_call_id": self.tool_call_id,
        }

    def execute(self, tool_executor: Callable[[str, Dict[str, Any]], str]) -> bool:
        """
        Helper to run local code and submit results.
        Level 3: Propagates tool_call_id to execute_pending_action to close the loop.
        """
        success = self._runs_client.execute_pending_action(
            run_id=self.run_id,
            thread_id=self._thread_id,
            assistant_id=self._assistant_id,
            tool_executor=tool_executor,
            actions_client=self._actions_client,
            messages_client=self._messages_client,
            streamed_args=self.args,
            action_id=self.action_id,
            tool_name=self.tool_name,
            tool_call_id=self.tool_call_id,  # [L3] Pass ID to the execution layer
        )

        if success:
            self.executed = True

        return success
