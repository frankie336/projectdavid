import json
from dataclasses import dataclass
from typing import Any, Callable, Dict, Optional, Union


@dataclass
class StreamEvent:
    """Base class for all stream events."""

    run_id: str


@dataclass
class ContentEvent(StreamEvent):
    """Represents a text delta from the assistant."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class ReasoningEvent(StreamEvent):
    """Represents a 'thinking' delta (DeepSeek R1/V3)."""

    content: str

    def __str__(self):
        return self.content


# --- Code Execution Events ---


@dataclass
class HotCodeEvent(StreamEvent):
    """Represents real-time code being written/typed (The Matrix Effect)."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionOutputEvent(StreamEvent):
    """Represents stdout/stderr output from the code sandbox."""

    content: str

    def __str__(self):
        return self.content


@dataclass
class CodeExecutionGeneratedFileEvent(StreamEvent):
    """Represents a file generated by the code interpreter."""

    filename: str
    file_id: str
    base64_data: str
    mime_type: str

    def __repr__(self):
        return f"<GeneratedFile: {self.filename}>"


# --- NEW: Computer/Shell Events ---


@dataclass
class ComputerExecutionOutputEvent(StreamEvent):
    """Represents output from the shell/computer execution tool."""

    content: str

    def __str__(self):
        return self.content


# --- Tooling & Lifecycle ---


class ToolCallRequestEvent(StreamEvent):
    """
    Represents a fully accumulated tool call request.
    Contains the parsed arguments and a helper method to execute it.
    """

    def __init__(
        self,
        run_id: str,
        tool_name: str,
        args: Dict[str, Any],
        thread_id: str,
        assistant_id: str,
        _runs_client: Any,
        _actions_client: Any,
        _messages_client: Any,
    ):
        super().__init__(run_id)
        self.tool_name = tool_name
        self.args = args
        self._thread_id = thread_id
        self._assistant_id = assistant_id
        self._runs_client = _runs_client
        self._actions_client = _actions_client
        self._messages_client = _messages_client

    def execute(self, tool_executor: Callable[[str, Dict[str, Any]], str]) -> bool:
        """
        Executes the provided local function using the accumulated arguments
        and submits the result to the API.
        """
        return self._runs_client.execute_pending_action(
            run_id=self.run_id,
            thread_id=self._thread_id,
            assistant_id=self._assistant_id,
            tool_executor=tool_executor,
            actions_client=self._actions_client,
            messages_client=self._messages_client,
            streamed_args=self.args,
        )

    def __repr__(self):
        return f"<ToolCallRequestEvent tool='{self.tool_name}' args={self.args}>"


@dataclass
class StatusEvent(StreamEvent):
    """Represents a status change (e.g., complete, failed)."""

    status: str
